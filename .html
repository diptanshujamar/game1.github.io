<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Memory: Interactive Edition</title>
    <style>
        :root {
            --bg-base: #0a0a10;
            --card-back: linear-gradient(135deg, #1e1e24, #121217);
            --cyan: #00fff2;
            --green: #00ff66;
            --red: #ff0055;
            --yellow: #ffd700;
            --white: #ffffff;
            --glass: rgba(255, 255, 255, 0.03);
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg-base);
            color: var(--white);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            overflow: hidden;
            user-select: none;
            cursor: crosshair;
        }

        /* --- Interactive Mouse Glow --- */
        .cursor-glow {
            position: fixed;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 255, 242, 0.15) 0%, rgba(0,0,0,0) 60%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1;
            transition: width 0.2s, height 0.2s;
        }

        /* --- Click Ripple --- */
        .ripple {
            position: fixed;
            border-radius: 50%;
            border: 2px solid var(--cyan);
            transform: translate(-50%, -50%);
            animation: rippleAnim 0.5s ease-out forwards;
            pointer-events: none;
            z-index: 9999;
        }

        @keyframes rippleAnim {
            0% { width: 0; height: 0; opacity: 1; border-width: 4px; }
            100% { width: 120px; height: 120px; opacity: 0; border-width: 1px; }
        }

        /* --- Header & Stats --- */
        header {
            position: relative;
            text-align: center;
            margin-bottom: 15px;
            background: var(--glass);
            padding: 15px 30px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.05);
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 95%;
            max-width: 800px;
            z-index: 10;
            transition: transform 0.2s;
        }

        header:hover {
            transform: translateY(-2px);
            border-color: rgba(0, 255, 242, 0.3);
            box-shadow: 0 10px 40px rgba(0, 255, 242, 0.1);
        }

        h1 {
            color: var(--cyan);
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            text-shadow: 0 0 15px rgba(0, 255, 242, 0.5);
            letter-spacing: 3px;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 1rem;
            color: rgba(255,255,255,0.7);
        }

        .stat-box span { color: var(--yellow); text-shadow: 0 0 8px rgba(255, 215, 0, 0.4); }
        .combo-box span { color: var(--cyan); text-shadow: 0 0 8px rgba(0, 255, 242, 0.5); font-size: 1.2rem; }

        /* --- Progress Bar --- */
        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--cyan), var(--green));
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px var(--cyan);
        }

        /* --- Game Grid --- */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4/3; 
            position: relative;
            z-index: 5;
            perspective: 1200px; /* Enhanced 3D depth */
        }

        /* --- Card Styles --- */
        .card {
            background-color: transparent;
            cursor: pointer;
            position: relative;
            aspect-ratio: 1;
            transition: transform 0.2s ease, filter 0.2s ease;
        }

        /* Hover Physics */
        .card:hover:not(.flipped) {
            transform: translateY(-5px) scale(1.05);
            z-index: 10;
        }

        .card:hover:not(.flipped) .card-front {
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0, 255, 242, 0.4), inset 0 0 10px rgba(0, 255, 242, 0.2);
            color: var(--cyan);
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
            border-radius: 8px;
        }

        .card.flipped .card-inner { transform: rotateY(180deg); }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 2.5vw, 2.2rem);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.08);
            transition: all 0.3s;
        }

        .card-front {
            background: var(--card-back);
            color: rgba(255,255,255,0.1);
        }
        
        .card-front::after { content: 'âœ¦'; }

        .card-back {
            background: var(--white);
            color: #000;
            transform: rotateY(180deg);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }

        .card.matched .card-back {
            background: var(--green);
            border-color: #fff;
            box-shadow: 0 0 25px rgba(0, 255, 102, 0.6);
            animation: pop 0.4s ease-out;
        }

        @keyframes pop {
            0% { transform: rotateY(180deg) scale(1); }
            50% { transform: rotateY(180deg) scale(1.15); }
            100% { transform: rotateY(180deg) scale(1); }
        }

        .card.wrong .card-back {
            background: var(--red);
            color: white;
            box-shadow: 0 0 25px rgba(255, 0, 85, 0.6);
            animation: wrongShake 0.4s;
        }

        @keyframes wrongShake {
            0%, 100% { transform: rotateY(180deg) translateX(0); }
            25% { transform: rotateY(180deg) translateX(-8px); }
            75% { transform: rotateY(180deg) translateX(8px); }
        }

        /* --- Status Bar --- */
        #status-bar {
            margin-top: 20px;
            padding: 10px 30px;
            border-radius: 50px;
            background: rgba(0,0,0,0.5);
            color: var(--cyan);
            font-size: 1.1rem;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 242, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
        }

        /* --- Modal --- */
        .overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.4s;
        }

        .overlay.visible { visibility: visible; opacity: 1; }

        .overlay-content {
            border: 2px solid var(--cyan);
            padding: 40px 60px;
            text-align: center;
            background: rgba(10, 10, 16, 0.95);
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 255, 242, 0.2);
            transform: scale(0.9) translateY(20px);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .overlay.visible .overlay-content { transform: scale(1) translateY(0); }

        button {
            background: transparent;
            border: 2px solid var(--cyan);
            padding: 12px 40px;
            color: var(--cyan);
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            margin-top: 30px;
            border-radius: 50px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--cyan);
            z-index: -1;
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        button:hover { color: #000; box-shadow: 0 0 20px rgba(0, 255, 242, 0.6); }
        button:hover::before { transform: scaleX(1); transform-origin: left; }

        /* Confetti */
        .confetti { position: fixed; pointer-events: none; z-index: 999; }

        @media (max-width: 700px) {
            .grid-container { grid-template-columns: repeat(6, 1fr); aspect-ratio: 3/5; }
            h1 { font-size: 1.5rem; }
            .stats { font-size: 0.85rem; }
            .cursor-glow { display: none; } /* Disable custom glow on mobile for performance */
        }
    </style>
</head>
<body>

    <div class="cursor-glow" id="cursorGlow"></div>

    <header>
        <h1>NEON MEMORY</h1>
        <div class="stats">
            <div class="stat-box">Moves: <span id="moves">0</span></div>
            <div class="combo-box">Combo: <span id="combo">x0</span></div>
            <div class="stat-box">Pairs: <span id="matches">0</span>/24</div>
            <div class="stat-box">Time: <span id="timer">0</span>s</div>
        </div>
        <div class="progress-container">
            <div class="progress-fill" id="progressBar"></div>
        </div>
    </header>

    <div class="grid-container" id="grid"></div>

    <div id="status-bar">Tap anywhere to start!</div>

    <div class="overlay" id="overlay">
        <div class="overlay-content">
            <h2 style="color: var(--cyan); font-size: 2.5rem; margin-bottom: 5px; text-shadow: 0 0 15px var(--cyan);">SYSTEM CLEARED</h2>
            <p style="font-size: 1.2rem; margin: 10px 0;">Total Moves: <span id="final-moves" style="color:var(--yellow)">0</span></p>
            <p style="font-size: 1.2rem; margin: 5px 0;">Total Time: <span id="final-time" style="color:var(--yellow)">0</span>s</p>
            <p style="font-size: 1.2rem; margin: 5px 0;">Max Combo: <span id="final-combo" style="color:var(--green)">x0</span></p>
            <h3 id="grade-msg" style="margin-top: 25px; font-size: 1.5rem; color: var(--white);"></h3>
            <button onclick="restartGame()">REBOOT SYSTEM</button>
        </div>
    </div>

    <script>
        // --- Interactive Frontend Logic ---

        // 1. Mouse Ambient Glow Tracker
        const cursorGlow = document.getElementById('cursorGlow');
        document.addEventListener('mousemove', (e) => {
            cursorGlow.style.left = `${e.clientX}px`;
            cursorGlow.style.top = `${e.clientY}px`;
        });

        // 2. Click Ripple Effect
        document.addEventListener('mousedown', (e) => {
            const ripple = document.createElement('div');
            ripple.classList.add('ripple');
            ripple.style.left = `${e.clientX}px`;
            ripple.style.top = `${e.clientY}px`;
            document.body.appendChild(ripple);
            
            // Remove after animation completes
            setTimeout(() => { ripple.remove(); }, 500);
        });

        // --- Core Game Logic ---
        const symbols = [
            'ðŸŒ', 'ðŸ‘¾', 'ðŸš€', 'âš¡', 'ðŸ”‹', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ•¹ï¸',
            'ðŸ’Ž', 'ðŸ”¥', 'â˜„ï¸', 'ðŸ§¬', 'ðŸ”®', 'ðŸ›¡ï¸', 'âš”ï¸', 'ðŸ—ï¸',
            'ðŸŽµ', 'ðŸŽ§', 'ðŸ‘ï¸', 'ðŸŒ€', 'ðŸŽ­', 'ðŸŒŒ', 'ðŸŒ ', 'ðŸ›¸'
        ];
        
        const totalPairs = 24; 
        let cardsArray = [];
        let moves = 0, matchedPairs = 0, timer = 0, currentCombo = 0, maxCombo = 0;
        let timerInterval, confettiInterval;
        let hasFlippedCard = false, lockBoard = true; 
        let firstCard, secondCard;

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        document.body.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }, { once: true });

        function playSound(type) {
            if (audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'flip') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(500, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'match') {
                osc.type = 'square'; osc.frequency.setValueAtTime(300, now);
                osc.frequency.setValueAtTime(600, now + 0.1);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(80, now + 0.2);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
        }

        function initGame() {
            moves = 0; matchedPairs = 0; timer = 0; currentCombo = 0; maxCombo = 0;
            hasFlippedCard = false; lockBoard = true; firstCard = null; secondCard = null;
            
            document.getElementById('moves').innerText = '0';
            document.getElementById('matches').innerText = '0';
            document.getElementById('timer').innerText = '0';
            document.getElementById('combo').innerText = 'x0';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('overlay').classList.remove('visible');
            document.getElementById('grid').innerHTML = '';
            
            clearInterval(confettiInterval);
            document.querySelectorAll('.confetti').forEach(e => e.remove());

            cardsArray = [...symbols, ...symbols];
            cardsArray.sort(() => Math.random() - 0.5); // Quick shuffle
            
            createBoard();
            startPreview();
        }

        function createBoard() {
            const grid = document.getElementById('grid');
            cardsArray.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.symbol = symbol;
                
                // Staggered entrance animation
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                
                const cardInner = document.createElement('div');
                cardInner.classList.add('card-inner');
                const front = document.createElement('div'); front.classList.add('card-front');
                const back = document.createElement('div'); back.classList.add('card-back'); back.innerText = symbol;

                cardInner.appendChild(front); cardInner.appendChild(back); card.appendChild(cardInner);
                card.addEventListener('click', flipCard);
                grid.appendChild(card);

                setTimeout(() => {
                    card.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                    card.style.opacity = '1';
                    card.style.transform = 'translateY(0)';
                }, index * 20); // cascading load effect
            });
        }

        function startPreview() {
            updateStatus("Initializing Memory Banks...", "var(--cyan)");
            setTimeout(() => {
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => card.classList.add('flipped'));

                let count = 4;
                const countdown = setInterval(() => {
                    updateStatus(`Locking sequences in ${count}...`, "var(--yellow)");
                    count--;
                    if (count < 0) {
                        clearInterval(countdown);
                        cards.forEach(card => card.classList.remove('flipped'));
                        lockBoard = false;
                        updateStatus("SYSTEM READY. Begin Matching.", "var(--white)");
                        startTimer();
                    }
                }, 1000);
            }, 1000); // Wait for entrance animation to finish
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timer++; document.getElementById('timer').innerText = timer;
            }, 1000);
        }

        function flipCard() {
            if (lockBoard || this === firstCard) return;

            playSound('flip');
            this.classList.add('flipped');

            if (!hasFlippedCard) {
                hasFlippedCard = true; firstCard = this;
                return;
            }

            secondCard = this;
            moves++;
            document.getElementById('moves').innerText = moves;
            checkForMatch();
        }

        function checkForMatch() {
            let isMatch = firstCard.dataset.symbol === secondCard.dataset.symbol;
            isMatch ? disableCards() : unflipCards();
        }

        function disableCards() {
            lockBoard = true;
            setTimeout(() => {
                playSound('match');
                firstCard.classList.add('matched');
                secondCard.classList.add('matched');
                
                // Update Combo & Stats
                currentCombo++;
                if(currentCombo > maxCombo) maxCombo = currentCombo;
                document.getElementById('combo').innerText = `x${currentCombo}`;
                document.getElementById('combo').style.transform = 'scale(1.3)';
                setTimeout(() => document.getElementById('combo').style.transform = 'scale(1)', 200);

                matchedPairs++;
                document.getElementById('matches').innerText = matchedPairs;
                
                // Update Progress bar
                const progressPct = (matchedPairs / totalPairs) * 100;
                document.getElementById('progressBar').style.width = `${progressPct}%`;

                if(currentCombo > 2) updateStatus(`${currentCombo}x COMBO!`, "var(--green)", true);
                else updateStatus("DATA LINKED.", "var(--green)");
                
                resetBoard();

                if (matchedPairs === totalPairs) endGame();
            }, 400);
        }

        function unflipCards() {
            lockBoard = true;
            currentCombo = 0; // Break Combo
            document.getElementById('combo').innerText = `x0`;

            updateStatus("LINK FAILED.", "var(--red)");
            playSound('wrong');

            firstCard.classList.add('wrong');
            secondCard.classList.add('wrong');

            setTimeout(() => {
                firstCard.classList.remove('flipped', 'wrong');
                secondCard.classList.remove('flipped', 'wrong');
                updateStatus("Awaiting Input...", "var(--white)");
                resetBoard();
            }, 1000);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        function updateStatus(msg, color, scaleUp = false) {
            const sb = document.getElementById('status-bar');
            sb.innerText = msg;
            sb.style.color = color;
            sb.style.borderColor = color;
            sb.style.boxShadow = `0 0 15px ${color.replace(')', ', 0.3)').replace('var', '').replace('--', '')}`; // Hacky shadow
            
            if(scaleUp) {
                sb.style.transform = 'scale(1.1)';
                setTimeout(() => sb.style.transform = 'scale(1)', 300);
            }
        }

        function endGame() {
            clearInterval(timerInterval);
            document.getElementById('final-moves').innerText = moves;
            document.getElementById('final-time').innerText = timer;
            document.getElementById('final-combo').innerText = `x${maxCombo}`;
            
            const gradeMsg = document.getElementById('grade-msg');
            if (moves <= totalPairs + 4) gradeMsg.innerText = "RANK: S (FLAWLESS)";
            else if (moves <= totalPairs * 1.5) gradeMsg.innerText = "RANK: A (EXCELLENT)";
            else gradeMsg.innerText = "RANK: B (STANDARD)";

            setTimeout(() => {
                document.getElementById('overlay').classList.add('visible');
                spawnVictoryParticles();
            }, 600);
        }

        function restartGame() { initGame(); }

        // --- Performance Friendly Victory Particles ---
        function spawnVictoryParticles() {
            const colors = ['#00fff2', '#00ff66', '#ff0055', '#ffd700'];
            confettiInterval = setInterval(() => {
                const p = document.createElement('div');
                p.classList.add('confetti');
                document.body.appendChild(p);

                const size = Math.random() * 6 + 4 + 'px';
                p.style.width = size; p.style.height = size;
                p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                p.style.left = Math.random() * 100 + 'vw';
                p.style.top = '-10px';
                p.style.boxShadow = `0 0 10px ${p.style.backgroundColor}`;
                p.style.borderRadius = Math.random() > 0.5 ? '50%' : '0'; // Mix squares and circles
                
                const duration = Math.random() * 2 + 2;
                p.style.transition = `transform ${duration}s linear, opacity ${duration}s ease-in`;
                
                // Trigger animation next frame
                requestAnimationFrame(() => {
                    p.style.transform = `translateY(110vh) rotate(${Math.random() * 720}deg)`;
                    p.style.opacity = '0';
                });

                setTimeout(() => { if(p.parentNode) p.remove(); }, duration * 1000);
            }, 60); 
        }

        window.onload = initGame;
    </script>
</body>
</html>
